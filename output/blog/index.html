<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Sander Demeester - </title>
    <link rel="stylesheet" type="text/css" 
      href="http://twitter.github.com/bootstrap/assets/css/bootstrap.css" 
      media="screen">
    <link rel="stylesheet" type="text/css" href="/style.css">
  </head>
  <body>
    <div class='navbar'>
      <div class='navbar-inner'>
        <div class='container'>
          <a class='brand' href='/'>SD</a>
          <ul class='nav'>
            <li class='active'><a href='/'>Home</a></li>
            <li><a href='/about'>About</a></li>
   	    <li><a href='/blog'>Blog</a></li>			
	    <li><a href='/projects'>Projects</a></li>
          </ul>
        </div>
      </div>
    </div>
    <section class='content'>
      
<a href="/blog/znp/">Zero Knowledge Proof</a>
2013-04-02 10:45:51 +0000
<p>
  <!-- <article> -->
  <!-- 	<p>De normale manier voor Alice om iets te bewijzen aan Bob is door het hem te vertellen. Maar dan weet Bob dat iets ook en kan hij het verder vertellen aan andere entiteiten en Alice kan daar niks aan doen. Alice zou op een of andere manier dat &#8220;iets&#8221; willen bewijzen aan Bob zonder dat &#8220;iets&#8221; te moeten onthullen.</p>

<p>Om dit idee verder uit te leggen zal ik onderstaande tekst gebruik maken van 2 nieuwe personages, nl: Peggy, die de rol zal vervullen van de &#8220;prover&#8221;, en Victor, die de rol zal spelen van de &#8220;verifierer&#8221;.
<div class='read-more'><a href='/blog/znp/'>Verder lezen &rsaquo;</a></div> -->
  <!-- </article> -->
  
<a href="/blog/int_fac/">Visualisation of the Integer factorization process</a>
2012-08-09 21:35:01 +0000
<p>
  <!-- <article> -->
  <!-- 	<p>In getallen theorie zijn we vertrouwd met het idee dat elke natuurlijk getal kan worden ontbonden in priemfactoren. 
<div class='read-more'><a href='/blog/int_fac/'>Verder lezen &rsaquo;</a></div> -->
  <!-- </article> -->
  
<a href="/blog/RSA/">Chosen Ciphertext Attack against RSA</a>
2012-07-27 20:49:00 +0000
<p>
  <!-- <article> -->
  <!-- 	<p>We onderscheiden 2 soorten problemen als we het hebben over het &#8220;aanvallen&#8221; van cryptografische protocollen. 
Soort 1, aanvallen tegen de implementatie van het protocol. 
Soort 2, aanvallen tegen het protocol zelf. 
&lt;! &#8211; more &#8211;&gt;
De volgende 3 senario&#8217;s die ik beschrijf zijn bekende aanvallen tegen het RSA protocol.</p>

<p>Zeer korte beschrijving van het RSA protocol.
RSA krijgt zijn beveiliging door de moeilijkheid van het factoriseren van grote getallen. De public en private key zijn functies van een paar (200 of meer digits) priem getallen. Het bekomen van de plaintext van de public key en de ciphertext is equivalent met het factoriseren van het product bestaand uit 2 priem getallen.</p>

<p>Om de twee keys te maken kiezen we 2 random priem getallen van gelijk lengte, we noemen deze $p,q$. We bepalen het product.</p>

<script type="math/tex; mode=display">n = pq</script>

<p>We kiezen random een encryptie key $e$, zodanig dat $e$ en $(p-1)(q-1)$ relatief priem zijn. 
Daarna gebruiken we het <a href="http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm">extended euclidean algoritm</a> om een decryptie key $d$ te vinden zodanig dat</p>

<p><script type="math/tex">ed \equiv 1 \text{ mod } (p-1)(q-1)</script>
Of
<script type="math/tex">d = e^{-1} \text{ mod } ((p-1)(q-1))</script></p>

<p>We merken op dat $d$ en $n$ relatief priem zijn.  De getallen $e$ en $n$ zijn de public key, $d$ is de private key. $p,q$ zijn verder niet meer nodig, maar moeten wel geheim blijven.
Om een bericht $m$ te encrypteren delen we het eerst op in blokken smaller dan $n$, het resultaat, $e$ zal zijn bestaan uit gelijkaardige blokken die we $c_{i}$ zullen noemen.
De encryptie formule is de volgende:
<script type="math/tex">c_{i} = m_{i}^{e} \text{ mod n }</script>
Decrypteren is dan logischerwijze:
<script type="math/tex">m_{i} = c_{i}^{d} \text{mod n}</script>
Omdat
<script type="math/tex">c_{i}^{d}=(m_{i}^{e})^{d} = m_{i}^{ed}=m_{i}^{k(p-1)(q-1)+1} = m_{i}m_{i}^{k(p-1)(q-1)} = m_{i}*1=m_{i} \text{ alles mod n}</script>.</p>

<p><a href="http://sanderdemeester.be/maple/RSA-example.mw">maple voorbeeld</a></p>

<hr />

<p>Samenvatting van het protocol:</p>
<p>
Public Key:
n: product van 2 priem getallen, $p,q$ (beide getallen moeten geheim blijven)
e: relatief priem met $(p-1)(q-1)$
Private Key:
d: $e^{-1} \text{mod } ((p-1)(q-1))$
Encrypteren:
c: $c=m^{e} \text{ mod n }$
Decrypteren:
m: $m = c^{d} \text{ mod n }$
<hr />

Nu de werking van het protocol is begrepen ga ik 3 bekende scenario's tekenen waar deze manier van werken zijn doel mist. 

Scenario 1: 
	Eve, luistert in op de communicatie van Alice en slaagt erin om een ciphertext bericht $c$ te onderscheppen, $c$ is geÃ«ncrypteerd met Alice haar public key. Eve wilt het bericht kunnen lezen. 
	Wiskundig uitgedrukt wilt Eve het volgende doen,
	
	$$m = c^{d}$$

	Om $m$ te herstellen kiest Eve eerst een random getal $r$, zodanig dat $r$ kleiner is dan $n$ alsook Alice haar public key $e$, die gepubliceerd is.
	Alice voert de volgende berekeningen uit:
	
	$$x = r^{e} \text{ mod n}$$
	$$y = xc \text{ mod n}$$
	$$t = r^{-1} \text{mod n}$$
	
	Let op dat als $x = r^{e} \text{ mod n}$, dan $r = x^{d} \text{ mod n}$
	Nu moet Eve Alice overtuigen om y te signeren met haar private key, m.a.w $y$ te decrypteren (Let op, Alice decrypteert het bericht, niet een hash van het bericht). Alice heeft $y$ nog nooit gezien, dus ze signed $y$
	
	$$u = y^{d} \text{mod n}$$
	
	Alice stuurt het resultaat terug door naar Eve die 

	$$tu \text{ mod n}  = r^{-1}y^{d} \text{ mod n} = r^{-1}x^{d}c^{d} \text{ mod n} = c^{d} \text{ mod n} = m$$

	berekent, eve beschikt nu over m.

Senario 2:
	Trent is een publieke computer notaris. Als Alice een document laat notaliseren, stuurt ze het document naar Trent. Trent signeert het document een RSA digital signature en stuurt het 
	document terug naar Alice (opnieuw wordt hier geen one-way hash function gebruikt, Trent encrypteert het volledige document met zijn private key).
	
	Mallory wilt dat Trent een bericht signeert dat hij normaal zou weigeren om te signeren. Wat de reden ook is, hij zou het nooit doen uit vrije wil. We noemen dit bericht $m'$.
	Eerst, Mallory kiest een arbitrere waarde $x$ en berekent 
	
	$y = x^{e} \text{ mod n}$, waar $e$ Trent zijn public key is, deze moet publiek zijn anders zouden andere entiteiten zijn signature niet kunnen controleren.
	
	Daarna berekent Mallory,
	
	$$m = ym' \text{ mod n}$$

	Mallory stuurt dit resultaat naar Trent, die het resultaat $m'^{d} mod \text{ } n$ terug geeft. Wat nu moet gebeuren is

	$(m^{d} \text{ mod n})x^{-1} \text{ mod n}$, wat gelijk is aan $n'^{d}$ en dus de signature is van $m'$

	Er zijn verschillende werkwijze's mogelijk om het zelfde resultaat te bekomen en worden besproken in volgende papers: 
	<a href="http://www.dtc.umn.edu/~odlyzko/doc/arch/rsa.attack.pdf">[G.I. Davida, "Chosen Signture Cryptanalysis of the RSA (MIT) Public Key Cryptosystem"] </a>
	<a href="faculty.nps.edu/dedennin/publications/digitalsigsrsa.pdf">[D.E. Denning, "Digital Signaatures with RSA and Other Pubilc-Key Cryptosystems"] </a>
	<a href="http://wenku.baidu.com/view/78bfd93767ec102de2bd89e3.html">[Y. Desmedt and A.M. Odlykzo, "A Chosen Text Attack on the RSA Cryptosystem and Some Discrete Logarithm Problems"] </a>
	
	De manier van werken die wordt gebruikt is het zelfde voor alle exploits, en is dat de machtsverheffing de multipliciteits structuur behoudt van zijn input:

	$$(xm)^{d} \text{ mod n} = x^{d}m^{d} \text{ mod n}$$

Senario 3:
	Eve wilt dat Alice $m_{3}$ signed. Ze genereert twee berichten, $m_{1},m_{2}$ zodanig dat
	
	$$m_{3} \equiv m_{1}m_{2} (\text{ mod n})$$
	
	Als Eve instaat is om Alice $m_{1}$ en $m_{2}$ te laten signeren kan ze volgende berekening toepassen om $m_{3}$ te bekomen.

	$$m_{3}^{d} = (m_{1}^{d})(m_{2}^{d} \text{ mod n})$$
Een link naar een uitgewerkt voorbeeld met maple.

Conclusie: 
Gebruik RSA nooit om een random document te signen.
 Maak altijd eerst een message digest van het document met een one-way hashing functie. <a href="http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=35455">ISO 9796</a> block formaat voorkomt dit soort aanvallen.

<iframe src="//www.facebook.com/plugins/like.php?href=http%3A%2F%2Fwww.sanderdemeester.be%2Fd%2Fnode%2F31&amp;send=false&amp;layout=standard&amp;width=450&amp;show_faces=true&amp;action=like&amp;colorscheme=light&amp;font&amp;height=80&amp;appId=207404839325473" scrolling="no" frameborder="0" style="border:none; overflow:hidden; width:450px; height:80px;" allowtransparency="true"></iframe>
</p>
 -->
  <!-- </article> -->
  
<a href="/blog/first/">First post</a>
2012-02-10 09:00:00 +0000
<p>
  <!-- <article> -->
  <!-- 	<p>Hello world
<div class='read-more'><a href='/blog/first/'>Verder lezen &rsaquo;</a></div> -->
  <!-- </article> -->
  
<a href="/blog/AES/">Advanced Encryption Standard (AES)</a>
2012-01-07 19:59:01 +0000
<p>
  <!-- <article> -->
  <!-- 	<p>Encryption with AES encryption algoritm.
    AES werkt met blokken van 16-byte groot, zonder rekening te houden met de key-lengte. AES maakt gebruik van permutaties en een subsitutie-network als interne structuur. Het aantal iteraties dat gebruikt wordt bij het de &#8220;key scheduling&#8221; hangt af van de key lengte.
<div class='read-more'><a href='/blog/AES/'>Verder lezen &rsaquo;</a></div> -->
  <!-- </article> -->
  
  

    </section>
    <script type="text/javascript">
      
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-34425622-1']);
      _gaq.push(['_trackPageview']);
      
      (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
      
    </script>
  </body>
</html>
